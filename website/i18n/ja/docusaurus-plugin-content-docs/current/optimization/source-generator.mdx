---
title: Source Generator
---

:::caution
This feature requires Unity 2021.3 or later.
:::

The main bottleneck in DI is metaprogramming. By default, VContainer does this through reflection, but has the ability to further accelerate it through compile-time code generation.

VContainer, does this by utilizing the Roslyn SourceGenerator to pre-generate the code needed for metaprogramming.

[Roslyn Source Generator](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview) is a part of C# compiler toolchain.
This is a standard metaprogramming feature in new .NET and C# development.
(Yes, for example, in other languages, it is a macro, or something like that.)

SourceGenerator, like IL weaving, does not pollute human-written code. However, it is easier to maintain than IL and easier to check the generated code.

:::info
In the old version of VContainer, this feature was used by IL weaving using `Mono.Cecil`.
Since VContainer 1.13.0, we have moved to Roslyn Source Generator.
:::

Source Generator is also described in the Unity manual.
- https://docs.unity3d.com/Manual/roslyn-analyzers.html


## How to enable VContainer Source Generator

### 1. Add `VContainer.SourceGenerator.dll` to your project.

Download `VContainer.SourceGenerator.dll from the release page.
https://github.com/hadashiA/VContainer/releases

And Add this to somewhere under Assets/ folder in your project.

### 2. Mark as `RoslynAnalizer`

Select `VcContainer.SourceGenerator.dll` in project.
And, click label icon in bottom of the inspector window.
Enter “RoslynAnalyzer” into the text input window in the Asset Labels sub-menu.

![](./assets/screenshot_enablecodegen.png)

## Limitation

SourceGenerator acceleration is not supported for type definitions like the following. (works by reflection)

- Nested classes
- Struct (value type)
- If the access level is less than internal (for example, private), even if `[Inject]` is added, SourceGenerator is not supported.

## Remarks

With VContainer, for example, the following code (as IL) is automatically generated:

```csharp
class ClassA
{
    private sealed class __GeneratedInjector : IInjector
    {
        public object CreateInstance(IObjectResolver resolver, IReadOnlyList<IInjectParameter> parameters)
        {
            I6 fromConstructor = resolver.ResolveOrParameter<I6>("fromConstructor1", parameters);
            I7 fromConstructor2 = resolver.ResolveOrParameter<I7>("fromConstructor2", parameters);
            return new ClassA(fromConstructor, fromConstructor2);
        }

        public void Inject(object instance, IObjectResolver resolver, IReadOnlyList<IInjectParameter> parameters)
        {
            ClassA clasA = (ClassA)instance;
            I3 service = resolver.ResolveOrParameter<I3>("service3", parameters);
            I4 service2 = resolver.ResolveOrParameter<I4>("service4", parameters);
            allInjectionFeatureService.MethodInjectable1(service, service2);
            I5 service3 = resolver.ResolveOrParameter<I5>("service5", parameters);
            I6 service4 = resolver.ResolveOrParameter<I6>("service6", parameters);
            classA.MethodInjectable2(service3, service4);
            classA.PrivatePropertyInjectable = resolver.Resolve<I2>();
            classA.PublicPropertyInjectable = resolver.Resolve<I3>();
            classA.privateFieldInjectable = resolver.Resolve<I4>();
            classA.PublicFieldInjectable = resolver.Resolve<I5>();
        }
   }
```
