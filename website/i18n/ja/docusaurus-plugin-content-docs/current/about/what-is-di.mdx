---
title: DIって何 ?
---

DI(=Dependency Injection) は、オブジェクト指向プログラミングの一般的なテクニック/パターンのことです。あるクラスのコードの中から、「委譲先のオブジェクトがどこからやってくるのか?」という情報を消すことで、クラスの実装同士を疎結合にする、というのが主なアイデアです。

DIをすると、クラスのコードを変更せずともクラス同士の依存関係をつなぎかえることができるので、テスタビリティやある種のメンテナンス性が改善する... とかとか一般的には言われています。
教科的な話を徹底することが現代でも常に強いメリットを持つかどうかはともかく、クラス同士の依存関係を結びつけるやりかたに一貫したスタイルを設けることはある種の快適さがあります。

:::note
C# では、サーバやコンソールアプリケーションを書くための 設定・ロギング・などを整備する標準的な仕組みとして [Generic Host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-5.0) というものがありますが、これはDIをベースにしたフレームワークとしてデザインされてます。
サーバのフレームワークとしてデファクトスタンダードといえる [ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-5.0) もまたDIベースです。

Generic Host をはじめとする Mircosoft.Extensions.* の名前を冠したパッケージは、 [dotnet/runtime](https://github.com/dotnet/runtime) リポジトリ内で管理されており、.NET環境やサーバサイドではかなり標準的な位置付けです。[Microsoft.Extensions.DependencyInjection](https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection) は、DIの基本的な機能を提供している他、実装のみを他のDIライブラリと置き換える仕組みも持っています。

C# でDIを使用するプログラミングをするなら要チェックだ!
:::

どんなプログラミングのパラダイムを用いるにしても、「モジュール結合度は低く」、「モジュール凝集度は高く」、とするのが基本です。オブジェクト指向では、*オブジェクト* を通してこれを行います。

1. オブジェクトは自身の責務について、ごちゃごちゃした詳細を外から隠蔽する。(カプセル化)
2. オブジェクトは自身の責務ではない仕事については、別のオブジェクトへ委譲する。

よさそうです。しかし実際にこれを完璧に行おうとするのは意外に簡単ではありません。
あるクラスのコードのなかに、別のクラスへの委譲を書くとるうと、単純に考えれば委譲先のオジェクトの生成方法あるいは実体の参照方法をそこに書くことになります。でもそうなると、コードを書き換えなければ実装が交換可能ではありません。また、委譲元が委譲先のインターフェイス以上の詳細をある程度知っている状態であると言えます。
これを避けるには、外側からオブジェクトの参照を渡してあげるしかありません。DI とはつまりそれを行うパターンのことです。

- 合わせて読みたい:
  - [Manning | Dependency Injection in .NET](https://www.manning.com/books/dependency-injection-in-dot-net)
  - [Lightweight IoC Container for Unity - Seba's Lab](https://www.sebaslab.com/ioc-container-unity-part-1/)


## 用語集 {#terminorogy}

- **DIコンテナ:** 参照関係を管理したいオブジェクトたちをまとめて保持する場所のこと。
- **Composition Root:** 依存関係についての設定をまとめて記述する場所。これを一箇所にまとめてアプリケーションのコードとは分離することで、各クラスのコードから委譲先を検索したり生成するコードが消える。
- **Auto-wiring:** オブジェクトが必要とするオブジェクトを外から渡して、参照関係を自動的に組み立てる機能のこと。普通、DIコンテナはこの機能を持っている。
- **IoC (Inversion of Control = 制御の反転):** 制御フローに責任を持つオブジェクトが先に呼び出され、中心的な制御を担う形にすること。ごく素朴なプログラミングでは、処理の起点になるのはユーザ入力や割り込みを受けつける場所になります。一般にアプリケーションフレームワークはこれを反転(Inversion)させ、あくまで制御フローだけに責任を持つオブジェクトから処理がはじまる形になってます。

## なぜ Unity にDIを ? {#whi-di-for-unity}

Unityにおいては、 `MonoBehaviour` が アプリケーション内では処理の起点になります。同時に、画面に表示するものを表現した 「Viewコンポーネント」の役割を持つのもまた `MonoBehaviour` です。

アプリケーション設計においては、「ドメインロジックとプレゼンテーション(Viewコンポーネント)の分離」がとても大事です。`MonoBehaviour` が多くの役割(イベントハンドリング、制御フロー、ドメインロジック呼び出し、etc...)を同時に兼ねていると、この原則が破綻しがちです。

DI の目的のひとつに IoC (制御の反転) があります。DIコンテナを使うと、 `MonoBehaviour` のようなUnityに依存した末端のオブジェクトじゃなくて、自由に定義した C# クラスの方を処理のはじまりにすることができます。
これは、制御フローおよびその他のドメインロジックと、ViewコンポーネントとしてのMonoBehaviourの機能との分離に役立ちます。

Viewコンポーネントは、実行時に生成/破棄されるかもしれないので、寿命が不安定と言えます。一方、制御フローやドメインロジックなどの「機能」を司るオブジェクトは、安定した寿命を持ちます。
一般的に、Viewコンポーネントから 制御フローやドメインロジックを分離することで、オブジェクト同士の参照関係の管理がシンプルになります。

これは 作者 ([@hadashiA](https://twitter.com/hadashiA)) がDIを好む主な理由です。

- 合わせて読みたい:
  - [Unity専用最速DIコンテナVContainer と、UnityにおけるDIの勘所 - hadashiA](https://scrapbox.io/hadashiA/Unity%E5%B0%82%E7%94%A8%E6%9C%80%E9%80%9FDI%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8AVContainer_%E3%81%A8%E3%80%81Unity%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8BDI%E3%81%AE%E5%8B%98%E6%89%80)