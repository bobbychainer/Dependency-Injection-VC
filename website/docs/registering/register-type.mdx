---
title: Register Plain C# Type
---

There are various ways to use Register.
Let's take the following complex type as an example.

```csharp
class ServiceA : IServiceA, IInputPort, IDisposable { /* ... */ }
```

## Register Concrete Type

```cs
builder.Register<ServiceA>(Lifetime.Singleton);
```

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(ServiceA serviceA) { /* ... */ }
}
```

## Register as Interface

```csharp
builder.Register<IServiceA, ServiceA>();
```

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}
```

## Register as multiple Interface

```csharp
builder.Register<ServiceA>(Lifetime.Singleton)
    .As<IServiceA, IInputPort>();
```

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}

class ClassB
{
    public ClassB(IInputPort inputPort) { /* ... */ }
}
```

## Register all implemented interfaces automatically

```csharp
builder.Register<ServiceA>(Lifetime.Singleton)
    .AsImplementedInterfaces();
```

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}

class ClassB
{
    public ClassB(IInputPort inputPort) { /* ... */ }
}
```

## Register all implemented interfaces and concrete type

```csharp
builder.Register<ServiceA>(Lifetime.Singleton)
    .AsImplementedInterfaces()
    .AsSelf();
```

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(IServiceA serviceA) { /* ... */ }
}

class ClassB
{
    public ClassB(IInputPort inputPort) { /* ... */ }
}

class ClassB
{
    public ClassB(ServiceA serviceA) { /* ... */ }
}
```

## Register lifecycle marker interfaces

```csharp
class GameController : IStartable, ITickable, IDisposable { /* ... */ }
```

```csharp
builder.RegisterEntryPoint<GameController>();
```

:::note
This is similar to `Register<GameController>(Lifetime.Singleton).AsImplementedInterfaces()`
:::

If you want to customize the exception handling for entry points, you can register a callback with the following.

```csharp
builder.RegisterEntryPointExceptionHandler(ex =>
{
    UnityEngine.Debug.LogException(ex);
    // Additional process ...
});
```

If you have multiple EntryPoints, you have the option to use the following declaration as grouping.

```csharp
builder.UseEntryPoints(Lifetime.Scoped, entryPoints =>
{
   entryPoints.Add<ScopedEntryPointA>();
   entryPoints.Add<ScopedEntryPointB>();
   entryPoints.Add<ScopedEntryPointC>().AsSelf();
   entryPoints.OnException(ex => ...)
});
```

This is the same as:

```csharp
builder.RegisterEntryPoint<ScopedEntryPointA>(Lifetime.Scoped);
builder.RegisterEntryPoint<ScopedEntryPointB>(Lifetime.Scoped);
builder.RegisterEntryPoint<ScopedEntryPointC>(Lifetime.Scoped).AsSelf();
builder.RegisterEntryPointExceptionHandler(ex => ...);
```

See the [Plain C# Entry point](../integrations/entrypoint) section for more information.

## Register instance

```csharp
// ...
var obj = new ServiceA();
// ...

builder.RegisterInstance(obj);
```

:::note
`RegisterIntance` always has a `Scoped` lifetime, so it has no arguments.
:::

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(ServiceA serviceA) { /* ... */ }
}
```

##  Register instance as interface

Use `As*` declarations.

```csharp
builder.RegisterInstance<IInputPort>(serviceA);

builder.RegisterInstance(serviceA)
    .As<IServiceA, IInputPort>();

builder.RegisterInstance()
    .AsImplementedInterfaces();
```

## Register instance to set up from delegate

Instance creation can be delegated to a lambda expression or another method or class.

```csharp
builder.Register<IFoo>(_ => new Foo(), Lifetime.Scoped);
```

It can resolve like this:

```csharp
class ClassA
{
    public ClassA(IFoo foo) { /* ...*/ }
}
```

The first argument that can be used in the expression is `IObjectResolver`.
Using this, we can retrieve and use the registered object.

```csharp
builder.Register<IFoo>(container =>
{
    var serviceA = container.Resolve<ServiceA>();
    return serviceA.ProvideFoo();
}, Lifetime.Scoped);
```

`IObjectResolver.Instantiate` can also be used to generate GameObjects executed inject.

```csharp
builder.Register(container =>
{
    return container.Instantiate(prefab);
}, Lifetime.Scoped);

```
See [Use Container directory](../container-api/use-container-directory) more information.

:::note
These delegates will be executed only once during scope construction.
If you want to create an instance at any time during runtime, please refer to [Register Factory](./register-factory).
:::


## Register type-specific parameters

If the types are not unique, but you have a dependency you want to inject at startup, you can use the following:

```csharp
builder.Register<SomeService>(Lifetime.Singleton)
    .WithParameter<string>("http://example.com");
```

Or, you can name a paramter with a key.

```csharp
builder.Register<SomeService>(Lifetime.Singleton)
    .WithParameter("url", "http://example.com");
```

It can resolve like this:


```csharp
class SomeService
{
    public SomeService(string url) { /* ... */ }
}
```

This Register only works when being injected into `SomeService`.

```csharp
class OtherClass
{
    // ! Error
    public OtherClass(string hogehoge) { /* ... */ }
}
```
