---
title: Source Generator
---

:::caution
This feature requires Unity 2021.3 or later.
:::

VContainer has the ability to perform the meta programming part faster by generating code at compile time.

In the old version, this was achieved by IL weaving using `Mono.Cecil`.
Since VContainer 1.13.0, we have moved to Roslyn Source Generator.

Roslyn Source Generator is a pre-code generator supported by Roslyn, the C# compiler toolchain.

This method is integrated into Roslyn and is the standard method going forward in the C# development environment. Also, as with IL code generation, it does not pollute human-written source code.

Source Generator is also described in the Unity manual.
- https://docs.unity3d.com/Manual/roslyn-analyzers.html

With VContainer, for example, the following code (as IL) is automatically generated:

## How to enable VContainer Source Generator

### 1. Download `VContainer.SourceGenerator.dll` to your project. (Somewhere under Assets/ folder)

Download `VContainer.SourceGenerator.dll from the release page.
https://github.com/hadashiA/VContainer/releases


### 2. Mark as ``

The next time the specified assembly is compiled, VContainer will make changes to the compiled dll.

If it succeeds, it will be logged. For example:

## Limitation

- Nested classes
- Struct

##

```csharp
class ClassA
{
    private sealed class __GeneratedInjector : IInjector
    {
        public object CreateInstance(IObjectResolver resolver, IReadOnlyList<IInjectParameter> parameters)
        {
            I6 fromConstructor = resolver.ResolveOrParameter<I6>("fromConstructor1", parameters);
            I7 fromConstructor2 = resolver.ResolveOrParameter<I7>("fromConstructor2", parameters);
            return new ClassA(fromConstructor, fromConstructor2);
        }

        public void Inject(object instance, IObjectResolver resolver, IReadOnlyList<IInjectParameter> parameters)
        {
            ClassA clasA = (ClassA)instance;
            I3 service = resolver.ResolveOrParameter<I3>("service3", parameters);
            I4 service2 = resolver.ResolveOrParameter<I4>("service4", parameters);
            allInjectionFeatureService.MethodInjectable1(service, service2);
            I5 service3 = resolver.ResolveOrParameter<I5>("service5", parameters);
            I6 service4 = resolver.ResolveOrParameter<I6>("service6", parameters);
            classA.MethodInjectable2(service3, service4);
            classA.PrivatePropertyInjectable = resolver.Resolve<I2>();
            classA.PublicPropertyInjectable = resolver.Resolve<I3>();
            classA.privateFieldInjectable = resolver.Resolve<I4>();
            classA.PublicFieldInjectable = resolver.Resolve<I5>();
        }
   }
```
